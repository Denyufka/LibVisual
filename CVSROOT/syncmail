#!/usr/bin/python
# -*- Mode: python -*-

"""Complicated notification for CVS checkins.

This script is used to provide email notifications of changes to the CVS
repository.  These email changes will include context diffs of the changes.
Really big diffs will be trimmed.

This script is run from a CVS loginfo file (see $CVSROOT/CVSROOT/loginfo).  To
set this up, create a loginfo entry that looks something like this:

    mymodule /path/to/this/script %%{sVv} some-email-addr@your.domain

To enable multidirectory messages, add a commitinto entry that looks like:

    mymodule /path/to/this/script -d

(Without being called from commitinfo, syncmail will produce a separate email
for each directory that files are modified in.)

In this example, whenever a checkin that matches `mymodule' is made, this
script is invoked, which will generate the notification email, and send it
to some-email-addr@your.domain.

    Note: This module used to also do repository synchronizations via
    rsync-over-ssh, but since the repository has been moved to SourceForge,
    this is no longer necessary.  The syncing functionality has been ripped
    out in the 3.0, which simplifies it considerably.  Access the 2.x versions
    to refer to this functionality.  Because of this, the script is misnamed.

It no longer makes sense to run this script from the command line.  Doing so
will only print out this usage information.

Usage:

    %(PROGRAM)s [options] <%%sVv> recipients
    %(PROGRAM)s -d directory files

Where options is:

    --cvsroot=<path>
        Use <path> as the environment variable CVSROOT.  Otherwise this
        variable must exist in the environment.

    --help
    -h
        Print this text.

    --subject=<subject>
        Set the subject line for the mail.
        The following patterns in <subject> will be substituted
        !{modules}    the names of the CVS modules being modified
        !{dirnames}   the names of the directories being modified
        !{filenames}  the names of the files being modified
        !{revisions}  the names and revision numbers of the files being modified
        !{username}   the name of the user making the commit
        The default value is '%(SUBJECT)s'

    --mailprog=<mailprog>
        Set the program used to send mail.
        The default value is '%(MAILPROG)s'

    --mailcmd=<mailcmd>
        Set the command used to send mail.
        The following patterns in <mailcmd> will be substituted
        !{mailprog}   the program used to send mail, as set by --mailprog
        !{subject}    the subject line for the mail, as set by --subject
        !{recipients} the list of recipients of the mail
        The default value is '%(MAILCMD)s'

    --mailhead=<mailhead>
        The header of the mail.  This is passed to the stdin of the mailprog,
        followed by the body of the mail.
        The following patterns in <mailhead> will be substituted
        !{subject}    the subject line for the mail, as set by --subject
        !{recipients} the list of recipients of the mail
        \\n           will be substituted with a newline
        The default is: '%(MAILHEAD)s'

    --context=#
    -C #
        Include # lines of context around lines that differ (default: 2).

    -c
        Produce a context diff (default).

    -u
        Produce a unified diff (smaller, but harder to read).

    -n
        Don't include diffs.

    --link-new=<template>
        Produce links to new files, using template.  <template> is a string,
        in which the following may be used:
        !{file} is expanded into the filename, relative to CVS Root.
        !{newrev} is expanded into the new revision number.

    --link-mod=<template>
        Produce links to modified files, using template.  <template> is a
        string, in which the following may be used:
        !{file} is expanded into the filename, relative to CVS Root.
        !{oldrev} is expanded into the old revision number.
        !{newrev} is expanded into the new revision number.

    --link-rem=<template>
        Produce links to removed files, using template.  <template> is a
        string, in which the following may be used:
        !{file} is expanded into the filename, relative to CVS Root.
        !{oldrev} is expanded into the old revision number.

    --link-viewcvs=<path>
        An alternative to specifying the --link-add, --link-mod, --link-rem
        parameters above: this sets all three up appropriately if viewcvs is
        being used.  <path> is the path to the base of viewcvs: ie, the path
        to the top page which lists all the modules.

    --no-diff-recipient=<email address>
        Specify an extra recipient, to which mails will be sent that are
        identical to the standard mail, except that no inline diffs will be
        included.  This can be used to send full, verbose messages to one
        mailing list, and shorter messages to a different mailing list.

    <%%sVv>
        CVS %%sVv loginfo expansion.  When invoked by CVS, this will be a single
        string containing the directory the checkin is being made in, relative
        to $CVSROOT, followed by the list of files that are changing and their
        revision numbers.

    recipients
        At least one email address.

    -d
        Mark last dir seen.  This is used when invoked from commitinfo.

    directory
        A directory in which files are being modified.

    files
        The filenames of modified files in <directory>.  These arguments are
        ignored.

"""

import os
import sys
import string
import time
import getopt
import re
import getpass
import urllib

# Command to send notification email
# See the usage docs for valid substitutions mailcmd can contain
MAILPROG = '/usr/sbin/sendmail'
MAILCMD = '!{mailprog} -t'
MAILHEAD = 'To: !{recipients}\\nSubject: !{subject}\\n\\n'

# Set the subject for the mail
# See the usage docs for valid substitutions the subject can contain
SUBJECT = 'Changes in !{dirnames}'
MAX_SUBJECT_LENGTH = 256

# Link patterns: if these are empty, no links are generated
CVSLINK_NEW, CVSLINK_MOD, CVSLINK_REM = '', '', ''

# Whether to include diffs in the email
INCLUDE_DIFFS = 1

# Whether to clean up temp files
NO_CLEAN = 0

# Diff trimming stuff
DIFF_HEAD_LINES = 20
DIFF_TAIL_LINES = 20
DIFF_TRUNCATE_IF_LARGER = 1000

# Process group: this is used to ensure uniqueness of temporary filenames
PGRP = os.getpgrp()

# File in which the last directory which was modified is stored.
LAST_FILE = '/tmp/#cvs.lastdir.%s'

# Files in which the modifications are stored, until the last directory is seen.
MOD_FILE = '/tmp/#cvs.files.%s.mod.%s'
ADD_FILE = '/tmp/#cvs.files.%s.add.%s'
REM_FILE = '/tmp/#cvs.files.%s.rem.%s'
LOG_FILE = '/tmp/#cvs.files.%s.log.%s'
DIFF_FILE = '/tmp/#cvs.files.%s.diff.%s'
FILE_PREFIX = '/tmp/#cvs.files.%s.'

PROGRAM = sys.argv[0]

def usage(code, msg=''):
    print __doc__ % globals()
    if msg:
        print msg
    sys.exit(code)

def calculate_diff(filespec, contextlines):
    file, oldrev, newrev = filespec
    file = os.path.basename(file)
    if oldrev == '':
        try:
            if os.path.exists(file):
                fp = open(file)
            else:
                update_cmd = "cvs -fn update -r %s -p %s" % (newrev, file)
                fp = os.popen(update_cmd)
            lines = fp.readlines()
            fp.close()
            lines.insert(0, '--- NEW FILE: %s ---\n' % file)
        except IOError, e:
            lines = ['***** Error reading new file: ',
                     str(e), '\n***** file: ', file, ' cwd: ', os.getcwd()]
    elif newrev == '':
        lines = ['--- %s DELETED ---\n' % file]
    else:
        # This /has/ to happen in the background, otherwise we'll run into CVS
        # lock contention.  What a crock.
        if contextlines > 0:
            difftype = "-C " + str(contextlines)
        else:
            difftype = "-u"
        diffcmd = "cvs -f diff -N -kk %s --minimal -r %s -r %s '%s'" % (
            difftype, oldrev, newrev, file)
        fp = os.popen(diffcmd)
        lines = fp.readlines()
        sts = fp.close()
        # ignore the error code, it always seems to be 1 :(
##        if sts:
##            return 'Error code %d occurred during diff\n' % (sts >> 8)
    if len(lines) > DIFF_TRUNCATE_IF_LARGER:
        removedlines = len(lines) - DIFF_HEAD_LINES - DIFF_TAIL_LINES
        del lines[DIFF_HEAD_LINES:-DIFF_TAIL_LINES]
        lines.insert(DIFF_HEAD_LINES,
                     '[...%d lines suppressed...]\n' % removedlines)
    return string.join(lines, '')



def link_to_diff(filespec):
    file, oldrev, newrev = filespec
    if oldrev == None or oldrev == '':
        return CVSLINK_NEW % vars()
    elif newrev == None or newrev == '':
        return CVSLINK_REM % vars()
    return CVSLINK_MOD % vars()



# Take a list of files, and return a list of the modules which the files
# are in.
# 'files' is a list of lists, each of which has a filename as its first entry
def calc_modules(files):
    modulelist = []

    # Extract the list of modules being altered
    module = ''
    for file in files:
        # extract the path to the directory containing the modified file
        newdir = os.path.dirname(file[0])
        # extract the module name
        newmodule = string.split(newdir, '/', 1)[0]
        if newmodule != module:
            module = newmodule
            modulelist.append(module)
    return modulelist



# Take a list of files, and return three space separated strings containing:
# the directories which the files are in, the list of filenames, and the
# list of filenames together with their revision numbers.
# 'files' is a list of lists, each of which has a filename as its first entry
def calc_names(files):
    dirlist = []
    filenamelist = []
    revlist = []

    # Extract the list of modules being altered
    dir = ''
    filename = ''
    rev = ''
    for file in files:
        # extract the path to the directory containing the modified file
        newdir = os.path.dirname(file[0]) + '/'
        # extract the filename of the modified file
	newfilename = file[0]
	# extract the filename and revision numbers of the files
	newrev = "%s,%s,%s" % (newfilename, file[1], file[2])

        if newdir != dir:
            dir = newdir
            dirlist.append(dir)
        if newfilename != filename:
            filename = newfilename
            filenamelist.append(filename)
        if newrev != rev:
            rev = newrev
            revlist.append(rev)

    return string.join(dirlist, ' '), string.join(filenamelist, ' '), string.join(revlist, ' ')



# Take a list of files, separating out the directories the files are in
# into groups, and returns a list of pairs, one for each directory, the first
# entry being the directory name, ('.' for top level) and the second entry
# being the list of filenames in that directory.
# 'files' is a list of lists, each of which has a filename as its first entry
# 'modulelist' is the list of modules being modified
def group_files(modulelist, files):
    result = []
    # Running list of files in current dir
    filelist = []
    dir = '.'

    module = ''
    if len(modulelist) == 1:
        module = modulelist[0]

    for file in files:
        # extract the path to the directory containing the modified file
        newdir = os.path.dirname(file[0])
        if module:
            if begin_is(newdir, module):
                newdir = newdir[len(module) + 1:]
                
        if newdir == '':
            newdir = '.'
            
        filename = os.path.basename(file[0])
        if newdir != dir:
            if filelist:
                result.append((dir, filelist))
            dir = newdir
            filelist = []

        if not filename in filelist:
            filelist.append(filename)
        
    if filelist:
        result.append((dir, filelist))
        
    return result



# return a pretty printed version of the list of files
def list_files(modulelist, files):
    dirname_indent = 4    # How far directory names are indented
    filename_indent = 21  # How far filenames are indented
    maxwidth = 70         # Maximum desired length of a line

    groups = group_files(modulelist, files)
    output = []
    for group in groups:
        output.append(' ' * dirname_indent + group[0])
        output[-1] = string.ljust(output[-1], filename_indent - 1)
        output[-1] = output[-1] + ':' + ' ' + group[1][0]
        for filename in group[1][1:]:
            if (len(output[-1]) + 1 + len(filename) > maxwidth):
                output.append(' ' * filename_indent)
            output[-1] = output[-1] + ' ' + filename
    return string.join(output, '\n')



def dirname_cmp(a, b):
    dir_a = os.path.dirname(a[0])
    dir_b = os.path.dirname(b[0])
    if dir_a < dir_b: return -1
    if dir_a > dir_b: return 1
    if a[0] < b[0]: return -1
    if a[0] > b[0]: return 1
    return 0



def blast_mail(subject, recipients, modulelist, username, branch, modfiles, addfiles, remfiles, logmessage, diffs):
    # Prepare mail commands
    mailprog = MAILPROG
    mailcmd = (re.sub('!\{([a-z]*?)\}', '%(\\1)s', MAILCMD)) % vars()
    mailcmd = mailcmd + ' 2>&1 >/dev/null'
    mailhead = string.replace(MAILHEAD, '\\n', '\n')
    mailhead = (re.sub('!\{([a-z]*?)\}', '%(\\1)s', mailhead)) % vars()

    cvsroot = os.environ['CVSROOT']
    date = time.strftime('%a %b %d %Y  %H:%M:%S %Z', time.localtime(time.time()))
    fp = os.popen(mailcmd, 'w')
    fp.write(mailhead)
    fp.write('CVS Root:       %s\n' % cvsroot)

    if len(modulelist) == 1:
        fp.write('Module:         %s\n' % modulelist[0])
    else:
        fp.write('Modules:        %s\n' % string.join(modulelist, ' '))

    fp.write('Changes by:     %s\n' % username)
    fp.write('Date:           %s\n' % date)
    if branch != None:
        fp.write('Branch:         %s\n' % branch)
    fp.write('\n')
    fp.write('Log message:\n%s\n' % logmessage)
    fp.write('\n')
    if len(modfiles) != 0:
        fp.write('Modified files:\n%s\n' % list_files(modulelist, modfiles))
    if len(addfiles) != 0:
        fp.write('Added files:\n%s\n' % list_files(modulelist, addfiles))
    if len(remfiles) != 0:
        fp.write('Removed files:\n%s\n' % list_files(modulelist, remfiles))
    fp.write('\n')

    files = modfiles + addfiles + remfiles
    allfiles = []
    for file in files:
        if file not in allfiles:
            allfiles.append(file)
    allfiles.sort(dirname_cmp)
    
    # Append the links to cvs diffs
    if CVSLINK_NEW or CVSLINK_MOD or CVSLINK_REM:
        fp.write('Links:\n')
        for file in allfiles:
            link = urllib.quote(link_to_diff(file), '/:?&=')
            if link != '': link = link + '\n'
            fp.write(link)
        if INCLUDE_DIFFS:
            fp.write('\n')

    # Append the actual diffs
    if INCLUDE_DIFFS:
        fp.write('====Begin Diffs====\n')
        fp.write(diffs)
    fp.close()



# The beginning of a string, to see if it is pattern.
def begin_is(data, pattern):
    if data[0:len(pattern)] == pattern:
        return 1
    return 0



# Read input from stdin.  This contains the details of the modified files,
# but not in a very helpful format, and the log message.  As it turns out, the
# only information here that we can reliably extract is the log message and any
# branch information (becase any spaces in filenames aren't escaped, so we
# can't tell the difference between file "foo bar" being modified, and files
# "foo" and "bar" being modified).
#
# As a result, we simply extract the log message and branch information and
# return it, as a tuple (log, branch).  The log is returned as a string
# with whitespace at beginning and end removed.
#
# This function takes the argument 'dir', the name of the directory being
# modified relative to CVSROOT.
# We also extract the full pathname of the directory being modified, and
# use this together with the 'dir' argument to calculate and set the CVSROOT
# environment variable if it isn't already set.
def scan_input(dir):
    infolines = sys.stdin.readlines()
    state = 'init'
    logmessage = ''
    branch = None
    for infoline in infolines:
        # Read in first line, which should be path to root.
        if state == 'init':
            if begin_is(infoline, 'Update of '):
                mo = re.match('Update of (.*)', infoline)
                full_cvsdir_path = mo.group(1)
            state = ''

        # Once we've started reading the log, everything remaining is log.
        if state == 'log':
            infoline = string.rstrip(infoline)
            if infoline != '':
                logmessage = logmessage + string.rstrip(infoline) + '\n'
            continue

        # If this is a branch tag, remember it.
        if begin_is(infoline, 'Revision/Branch') or re.match('^\s*Tag:\s*[^\s]+', infoline):
            mo = re.match('[^:]+:\s*(.*)', infoline)
            if mo == None: continue
            branch = mo.group(1)
            continue

        # If this is a line declaring the log section, change state.
        # Assume that log message comes at the end: we don't ever change state
        # out of the log state, because one of the special phrases could quite
        # legitimately be part of the message.
        if begin_is(infoline, 'Log Message'): state = 'log'; continue

    # Calculate CVSROOT if not already set: it is the contents of
    # 'full_cvsdir_path' without any components which appear in 'dir'.
    if not os.environ.has_key('CVSROOT'):
        while dir[-1:] == '/': dir[-1:] == ''
        while full_cvsdir_path[-1:] == '/': full_cvsdir_path[-1:] == ''
        while os.path.basename(full_cvsdir_path) == os.path.basename(dir):
            full_cvsdir_path = os.path.dirname(full_cvsdir_path)
            dir = os.path.dirname(dir)
        os.environ['CVSROOT'] = full_cvsdir_path

    return string.rstrip(logmessage), branch



# Parse the specs to extract the list of modified, added or removed files.
# dir is the directory relative to the root CVS dir of the files.
def parse_specs(specs, dir):
    modfiles, addfiles, remfiles = [], [], []
    for spec in specs:
        if spec[1] == 'NONE':
            # No old revision => added file
            addfiles.append((os.path.join(dir, spec[0]), '', spec[2]))
        elif spec[2] == 'NONE':
            # No new revision => removed file
            remfiles.append((os.path.join(dir, spec[0]), spec[1], ''))
        else:
            # Modified file
            modfiles.append((os.path.join(dir, spec[0]), spec[1], spec[2]))
    return modfiles, addfiles, remfiles



# parse specs in the format:
# <dir> <filename>,<rev1>,<rev2>( <filename>,<rev1>,<rev2>)...
# (ie, as given to us by cvs)
# However, filenames may contain spaces, hence we need to be careful when
# splitting these up.  Assume filenames contain no commas.
# Returns a list of lists: (dir,(filename,rev1,rev2),(filename,rev1,rev2),...)
def parse_rawspecs(rawspecs):
    dir, rawspecs = string.split(rawspecs, None, 1)
    if rawspecs == '- New directory': return dir, None
    if rawspecs == '- Imported sources': return dir, None
    specs = []
    filename, rev1, rev2 = None, None, None
    for item in string.split(rawspecs, ','):
        if filename == None: filename = item; continue
        if rev1 == None: rev1 = item; continue
        if rev2 == None:
            pieces = string.split(item, ' ', 1)
            if len(pieces) == 1: pieces.append(None)
            rev2, nextfilename = pieces
            specs.append((filename, string.strip(rev1), string.strip(rev2)))
            filename = nextfilename
            rev1, rev2 = None, None
    if (filename, rev1, rev2) != (None, None, None):
        print 'Bogus filespec %s,%s,%s ignored' % (filename, rev1, rev2)

    return dir, specs



# Find a number which generates a logmessage filename which is either not yet
# used (ie, no file exists) or contains the exact same log message as we have.
def find_lastdir_num(logmessage):
    lastdir_num = 0
    while os.path.exists(LOG_FILE % (lastdir_num, PGRP)):
        log_file = LOG_FILE % (lastdir_num, PGRP)
        fp = open(log_file, 'r')
        saved_logmessage = string.join(fp.readlines(), '')
        if saved_logmessage == '': break
        if saved_logmessage == logmessage: break
        fp.close()
        lastdir_num = lastdir_num + 1
    return lastdir_num



# Save details of the info extracted to files, for collation into
# a single message.
def save_info(branch, logmessage, modfiles, addfiles, remfiles, diffs):
    lastdir_num = find_lastdir_num(logmessage)

    mod_file = MOD_FILE % (lastdir_num, PGRP)
    add_file = ADD_FILE % (lastdir_num, PGRP)
    rem_file = REM_FILE % (lastdir_num, PGRP)
    log_file = LOG_FILE % (lastdir_num, PGRP)
    diff_file = DIFF_FILE % (lastdir_num, PGRP)

    fd = open(log_file, 'w')
    fd.write(logmessage)
    fd.close()

    fd = open(MOD_FILE % (lastdir_num, PGRP), 'a')
    for item in modfiles: fd.write(string.join(item, ',') + '\n')
    fd.close()
    fd = open(ADD_FILE % (lastdir_num, PGRP), 'a')
    for item in addfiles: fd.write(string.join(item, ',') + '\n')
    fd.close()
    fd = open(REM_FILE % (lastdir_num, PGRP), 'a')
    for item in remfiles: fd.write(string.join(item, ',') + '\n')
    fd.close()
    fd = open(DIFF_FILE % (lastdir_num, PGRP), 'a')
    fd.write(diffs)
    fd.close()

    return lastdir_num



# Split a line representing a file and its revision numbers
def split_lines(line):
    return string.split(string.rstrip(line), ',')



# Load details of the info extracted to files, for collation into
# a single message.
def load_info(lastdir_num):

    mod_file = MOD_FILE % (lastdir_num, PGRP)
    add_file = ADD_FILE % (lastdir_num, PGRP)
    rem_file = REM_FILE % (lastdir_num, PGRP)
    diff_file = DIFF_FILE % (lastdir_num, PGRP)

    modfiles, addfiles, remfiles = None, None, None

    fd = open(MOD_FILE % (lastdir_num, PGRP), 'r')
    lines = fd.readlines()
    modfiles = map(split_lines, lines)
    modfiles.sort(dirname_cmp)
    fd.close()
    fd = open(ADD_FILE % (lastdir_num, PGRP), 'r')
    lines = fd.readlines()
    addfiles = map(split_lines, lines)
    addfiles.sort(dirname_cmp)
    fd.close()
    fd = open(REM_FILE % (lastdir_num, PGRP), 'r')
    lines = fd.readlines()
    remfiles = map(split_lines, lines)
    remfiles.sort(dirname_cmp)
    fd.close()
    fd = open(DIFF_FILE % (lastdir_num, PGRP), 'r')
    lines = fd.readlines()
    diffs = []
    for line in lines:
        if not line in diffs:
            diffs.append(line)
    diffs = string.join(diffs, '')
    
    fd.close()
    return modfiles, addfiles, remfiles, diffs



def remove_temp_files(lastdir_num):
    os.remove(MOD_FILE % (lastdir_num, PGRP))
    os.remove(ADD_FILE % (lastdir_num, PGRP))
    os.remove(REM_FILE % (lastdir_num, PGRP))
    os.remove(LOG_FILE % (lastdir_num, PGRP))
    os.remove(DIFF_FILE % (lastdir_num, PGRP))
    if os.path.exists(LAST_FILE % PGRP):
        os.remove(LAST_FILE % PGRP)



# Read the last dir that this commit involves, as set by the invocation from
# commitinfo
def get_lastdir():
    if not os.path.exists(LAST_FILE % PGRP):
        return None
    fp = open(LAST_FILE % PGRP, 'r')
    lastdir = string.join(fp.readlines(), '')
    fp.close()
    return lastdir



# scan args for options
def main():
    contextlines = 2
    from_commitinfo = 0
    no_diff_recipients = ''
    try:
        opts, args = getopt.getopt(sys.argv[1:], 'hC:cudn',
                                   ['context=', 'cvsroot=',
                                    'no-clean',
                                    'no-diff-recipient=', 'help',
                                    'link-new=', 'link-mod=', 'link-rem=',
                                    'link-viewcvs=', 'mailprog=',
                                    'mailcmd=', 'mailhead=', 'subject='])
    except getopt.error, msg:
        usage(1, msg)

    # parse the options
    for opt, arg in opts:
        if opt in ('-h', '--help'):
            usage(0)
        elif opt == '--cvsroot':
            os.environ['CVSROOT'] = arg
        elif opt in ('-C', '--context'):
            contextlines = int(arg)
        elif opt == '-c':
            if contextlines <= 0:
                contextlines = 2
        elif opt == '-u':
            contextlines = 0
        elif opt == '-d':
            from_commitinfo = 1
        elif opt == '-n':
            globals()['INCLUDE_DIFFS'] = 0
        elif opt == '--no-clean':
            globals()['NO_CLEAN'] = 1
        elif opt == '--no-diff-recipient':
            if no_diff_recipients != '':
                no_diff_recipients = no_diff_recipients + ' '
            no_diff_recipients = no_diff_recipients + arg
        elif opt == '--link-new':
            globals()['CVSLINK_NEW'] = arg
        elif opt == '--link-mod':
            globals()['CVSLINK_MOD'] = arg
        elif opt == '--link-rem':
            globals()['CVSLINK_REM'] = arg
        elif opt == '--link-viewcvs':
            globals()['CVSLINK_NEW'] = arg + '/!{file}?rev=!{newrev}&content-type=text/vnd.viewcvs-markup'
            globals()['CVSLINK_MOD'] = arg + '/!{file}.diff?r1=!{oldrev}&r2=!{newrev}'
            globals()['CVSLINK_REM'] = arg + '/!{file}'
        elif opt == '--subject':
            globals()['SUBJECT'] = arg
        elif opt == '--mailprog':
            globals()['MAILPROG'] = arg
        elif opt == '--mailcmd':
            globals()['MAILCMD'] = arg
        elif opt == '--mailhead':
            globals()['MAILHEAD'] = arg

    # If called from commitinfo, we should just store the first argument as
    # the name of the last directory seen, and then finish.
    if from_commitinfo:
        if not args:
            usage(1, 'No directory specified')
        fd = open(LAST_FILE % PGRP, 'w')
        fd.write(args[0])
        fd.close()
        return

    # If we get here, we're being called from loginfo, for a particular
    # directory.  We extract all the information we can, and then, if we're
    # the last directory, we send notification of the changes.

    # What follows is the specification containing the files that were
    # modified.  The argument actually must be split, with the first component
    # containing the directory the checkin is being made in, relative to
    # $CVSROOT, followed by the list of files that are changing.
    if not args:
        usage(1, 'No CVS module specified')

    # parse the specs to extract the details of the altered files
    dir, specs = parse_rawspecs(args[0])
    del args[0]

    # specs will be none if we are called for a new directory or imported
    # sources
    if specs == None: return

    # Extract the modifed, added and removed files from the specs
    modfiles, addfiles, remfiles = parse_specs(specs, dir)

    # Now, read input from stdin.  This contains the details of
    # the modified files, but not in a very helpful format, so all we
    # can reliably get is the log message and details of any branches
    # we're in.
    logmessage, branch = scan_input(dir)

    # Lose cvs lock: fork and wait in the child.
    # Parent process cannot wait for child process or that will cause parent
    # to retain cvs lock.  Urg!
    if os.fork():
        # in the parent
        # give up the lock you cvs thang!
        os._exit(0)

    # Wait for parent to give up cvs lock
    time.sleep(2)

    # Calculate the diffs
    diffs = ''
    if INCLUDE_DIFFS:
        allfiles = modfiles + addfiles + remfiles
        allfiles.sort(dirname_cmp)
        for file in allfiles:
            diffs = diffs + calculate_diff(file, contextlines)

    # Next, save details of the info extracted to files, for collation into
    # a single message.
    lastdir_num = save_info(branch, logmessage, modfiles, addfiles, remfiles, diffs)

    # Finish here unless we've now processed the last directory in the commit
    lastdir = get_lastdir()
    if lastdir != None and lastdir != os.path.join(os.environ['CVSROOT'], dir):
        return

    # FIXME: this is a hack to reduce probability of a bug rearing its head.
    # Problem is that, since each directory of the commit is processed by a
    # separate process, if the final directory finishes before any of the others
    # the details won't have been put into the temp files yet.
    # To fix this properly, we need to check that all directories have been
    # processed: simply keep a list of ones to process rather than the
    # final one, and then make second list as they're processed, and wait until
    # there are no entries missing.  -- Richard Boulton - 21 Feb 2002
    time.sleep(10)

    # Load info for modifications in all directories, and then clean it up
    modfiles, addfiles, remfiles, diffs = load_info(lastdir_num)
    if not globals()['NO_CLEAN']:
        remove_temp_files(lastdir_num)

    # Calculate the module names, directory names, and filenames
    allfiles = modfiles + addfiles + remfiles
    allfiles.sort(dirname_cmp)
    
    modulelist = calc_modules(allfiles)
    dirnames, filenames, revisions = calc_names(allfiles)

    # Extract the username
    username = 'anonymous'
    if os.environ.has_key('CVS_USERNAME'):
        username = os.environ['CVS_USERNAME']
    elif os.environ.has_key('CVS_USER'):
        username = os.environ['CVS_USER']
    else:
        try:
            username = getpass.getuser()
        except KeyError:
            pass

    # Prepare these parameters for applying substitutions: values to substitute
    # are not yet available.
    globals()['CVSLINK_NEW'] = re.sub('!\{([a-z]*?)\}', '%(\\1)s', CVSLINK_NEW)
    globals()['CVSLINK_MOD'] = re.sub('!\{([a-z]*?)\}', '%(\\1)s', CVSLINK_MOD)
    globals()['CVSLINK_REM'] = re.sub('!\{([a-z]*?)\}', '%(\\1)s', CVSLINK_REM)

    # Apply substitutions to parameters
    modules = string.join(modulelist, ' ')
    subject = (re.sub('!\{([a-z]*?)\}', '%(\\1)s', SUBJECT)) % vars()
    if len(subject) > MAX_SUBJECT_LENGTH:
        subject = subject[0:MAX_SUBJECT_LENGTH]

    # The remaining args should be the email addresses
    if not args:
        usage(1, 'No recipients specified')
    recipients = string.join(args)

    # Now for the mail command
    blast_mail(subject, recipients, modulelist, username, branch, modfiles, addfiles, remfiles, logmessage, diffs)

    if no_diff_recipients != '':
        globals()['INCLUDE_DIFFS'] = 0
        blast_mail(subject, no_diff_recipients, modulelist, username, branch, modfiles, addfiles, remfiles, logmessage, diffs)

    sys.stdout.write('Sent notification message.')
    sys.exit(0)



if __name__ == '__main__':
    main()
