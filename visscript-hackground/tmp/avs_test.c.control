#include <stdio.h>

#include "avs_lexer.h"

#include "tabs.h"

int main(int argc, char **argv)
{
	int i;
	AvsLexerContext ctx;
	AvsLexerTokenValue v;
	AvsLexerTokenType t;
	int sstack[1024], *sp = sstack, *psp;
	AvsLexerTokenValue vstack[1024], *vp = vstack;
	char *type[] = {
		"AvsLexerTokenEOF",
		"AvsLexerTokenInvalid",
		"AvsLexerTokenIdentifier",
		"AvsLexerTokenConstant",
		"AvsLExerTokenPunctuator",
	};
	AvsLexerTokenValue value;
	int lextoken, token;
	int state;
	int length;
	int lookup;

	avs_lexer_init(&ctx, argv[1], strlen(argv[1]));

	state = 0;
	lextoken = YYEMPTY;

	goto setstate;

newstate:
	sp++;
	
setstate:
	*sp = state;
	fprintf(stderr, "Entering state: %d\n", *sp);
	
	lookup = yypact[*sp];
	if (lookup == YYPACT_NINF)
		goto default_action;


	if (lextoken == YYEMPTY) {
		fprintf(stderr, "Reading a token: ");
		lextoken = avs_lexer_token(&ctx, &v);
		if (v.type == AvsLexerTokenConstant) {
			fprintf(stderr, "AVS: Constant: %f\n", v.v.constant);
			lextoken = CONSTANT;
		}
		if (v.type == AvsLexerTokenIdentifier) {
			fprintf(stderr, "AVS: Identifier: %s\n", v.v.identifier);
			lextoken = IDENTIFIER;
		}
		if (v.type == AvsLexerTokenPunctuator) {
			fprintf(stderr, "AVS: Punctuator: '%c'\n", v.v.punctuator);
			lextoken = v.v.punctuator;
		}
		fprintf(stderr, "Token type: %d %s\n", v.type, type[v.type]);
	}

	if (lextoken <= YYEOF) {
		lextoken = token = YYEOF;
		fprintf(stderr, "Now at end of input.\n");
	} else {
		token = yytranslate[lextoken]; 
		fprintf(stderr, "Next token is: %d\n", token);
	}

	lookup += token;
	if (lookup < 0 || lookup > YYLAST || yycheck[lookup] != token)
		goto default_action;
	
	lookup = yytable[lookup];
	if (lookup <= 0) {
		/* Reduce */
		if (lookup == 0 || lookup == YYTABLE_NINF) {
			fprintf(stderr, "ERRORNOUS STATE!\n");
			exit(1);
		}
		lookup = -lookup;
		goto reduce;
	}

	if (lookup == YYFINAL) {
		fprintf(stderr, "Accept rule!\n");
		/* return */
		exit(0);
	}

	/* Shift */
	fprintf(stderr, "Shifting token %s, ", yytname[token]);

	if (lextoken != YYEOF)
		lextoken = YYEMPTY;
	
	*++vp = v;
	state = lookup;
	goto newstate;

default_action:
	lookup = yydefact[state];
	if (lookup == 0) {
		fprintf(stderr, "Error in default state!\n");
		exit(1);
	}
	goto reduce;
	

reduce:
	length = yyr2[lookup];
	v = vp[1 - length];
	
	fprintf(stderr, "Reducing stack by rule %d\n", lookup - 1);

	switch (lookup) {
        	case 2:
			    { fprintf(stderr, "STATEMENT: %p\n", &v); ;}
		    break;

		case 3:
	    		{ fprintf(stderr, "EMPTY!\n"); ;}
		    break;

	}
	
	vp -= length;
	sp -= length;

	fprintf(stderr, "Stack now");
	for (psp = sstack; psp <= sp; psp++) {
		fprintf(stderr, " %d", *psp);
	}
	fprintf(stderr, "\n");
		
	*++vp = v;

	lookup = yyr1[lookup];
	state = *sp + yypgoto[lookup - YYNTOKENS];
	
//	if (0 <= state && state <= YYLAST && yycheck[state] == *sp)
	if (state >= 0 && state <= YYLAST && yycheck[state] == *sp)
		state = yytable[state];
	else
		state = yydefgoto[lookup - YYNTOKENS];
	
	goto newstate;

	return 0;
}
